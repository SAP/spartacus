<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>storefrontapp documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">storefrontapp documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>LibraryWithDependencies</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>tools/config/manage-dependencies.ts</code>
        </p>


            <p class="comment">
                <h3>Extends</h3>
            </p>
            <p class="comment">
                        <code><a href="../miscellaneous/typealiases.html#Library" target="_self" >Library</a></code>
            </p>

        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#externalDependencies">externalDependencies</a>
                                </li>
                                <li>
                                        <a href="#externalDependenciesForPackageJson">externalDependenciesForPackageJson</a>
                                </li>
                                <li>
                                        <a href="#scssImports">scssImports</a>
                                </li>
                                <li>
                                        <a href="#tsImports">tsImports</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="externalDependencies"></a>
                                        <span class="name"><b>externalDependencies</b><a href="#externalDependencies"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>externalDependencies:     <code>literal type</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>literal type</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="externalDependenciesForPackageJson"></a>
                                        <span class="name"><b>externalDependenciesForPackageJson</b><a href="#externalDependenciesForPackageJson"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>externalDependenciesForPackageJson:     <code>literal type</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>literal type</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="scssImports"></a>
                                        <span class="name"><b>scssImports</b><a href="#scssImports"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>scssImports:     <code>literal type</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>literal type</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="tsImports"></a>
                                        <span class="name"><b>tsImports</b><a href="#tsImports"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>tsImports:     <code>literal type</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>literal type</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import chalk from &#x27;chalk&#x27;;
import { execSync } from &#x27;child_process&#x27;;
import fs, { readFileSync } from &#x27;fs&#x27;;
import glob from &#x27;glob&#x27;;
import postcss from &#x27;postcss-scss&#x27;;
import semver from &#x27;semver&#x27;;
import * as ts from &#x27;typescript&#x27;;
import { PACKAGE_JSON, SPARTACUS_SCHEMATICS, SPARTACUS_SCOPE } from &#x27;./const&#x27;;
import {
  error,
  Library,
  logUpdatedFile,
  PackageJson,
  ProgramOptions,
  reportProgress,
  Repository,
  success,
  warning,
} from &#x27;./index&#x27;;

// ------------ Utilities ------------

/**
 * Read and parse json file content
 *
 * @param path json file path
 *
 * @returns content of the json
 */
function readJsonFile(path: string): any {
  return JSON.parse(fs.readFileSync(path, &#x27;utf-8&#x27;));
}

/**
 * Stringify and safe json file content
 *
 * @param path json file path
 * @param content content to save
 */
function saveJsonFile(path: string, content: any): void {
  fs.writeFileSync(path, JSON.stringify(content, undefined, 2));
}

/**
 * Get list of all imports (paths)
 *
 * @param sourceFile ts source file
 *
 * @returns set with import paths
 */
function getAllImports(sourceFile: ts.SourceFile): Set&lt;string&gt; {
  const imports &#x3D; new Set&lt;string&gt;();
  delintNode(sourceFile);

  function delintNode(node: ts.Node) {
    switch (node.kind) {
      case ts.SyntaxKind.ImportDeclaration:
        const imp &#x3D; node as ts.ImportDeclaration;
        const text &#x3D; imp.moduleSpecifier.getText();
        imports.add(text.replace(/[&#x27;&quot;]+/g, &#x27;&#x27;));
        break;
    }

    ts.forEachChild(node, delintNode);
  }
  return imports;
}

// ------------ Utilities end ------------

interface LibraryWithDependencies extends Library {
  tsImports: {
    [importPath: string]: {
      importPath: string;
      files: Set&lt;string&gt;;
      usageIn: {
        spec: boolean;
        lib: boolean;
        schematics: boolean;
        schematicsSpec: boolean;
      };
    };
  };
  scssImports: {
    [importPath: string]: {
      importPath: string;
      files: Set&lt;string&gt;;
    };
  };
  externalDependencies: {
    [dependency: string]: {
      dependency: string;
      files: Set&lt;string&gt;;
      usageIn: {
        spec: boolean;
        lib: boolean;
        schematics: boolean;
        schematicsSpec: boolean;
        styles: boolean;
      };
    };
  };
  externalDependenciesForPackageJson: {
    [dependency: string]: {
      dependency: string;
      files: Set&lt;string&gt;;
      usageIn: {
        spec: boolean;
        lib: boolean;
        schematics: boolean;
        schematicsSpec: boolean;
        styles: boolean;
      };
    };
  };
}

export function manageDependencies(
  repository: Repository,
  options: ProgramOptions
) {
  const libraries &#x3D; Object.values(repository)
    .map(
      (library: Library): LibraryWithDependencies &#x3D;&gt; {
        const tsImports: LibraryWithDependencies[&#x27;tsImports&#x27;] &#x3D; {};
        const scssImports: LibraryWithDependencies[&#x27;scssImports&#x27;] &#x3D; {};

        // Gather data about ts imports
        const tsFilesPaths &#x3D; glob.sync(&#x60;${library.directory}/**/*.ts&#x60;, {
          // Ignore assets json translation scripts
          // TODO: Remove when translation script will be moved to lib builder
          ignore: [&#x60;projects/assets/generate-translations-*.ts&#x60;],
        });

        tsFilesPaths.forEach((fileName) &#x3D;&gt; {
          const sourceFile &#x3D; ts.createSourceFile(
            fileName,
            readFileSync(fileName).toString(),
            ts.ScriptTarget.ES2015,
            true
          );

          const fileImports &#x3D; getAllImports(sourceFile);
          fileImports.forEach((val) &#x3D;&gt; {
            if (tsImports[val]) {
              tsImports[val].files.add(fileName);
            } else {
              tsImports[val] &#x3D; {
                importPath: val,
                files: new Set&lt;string&gt;([fileName]),
                usageIn: {
                  spec: false,
                  lib: false,
                  schematics: false,
                  schematicsSpec: false,
                },
              };
            }
          });
        });

        // Gather data about scss imports
        const scssFilesPaths &#x3D; glob.sync(&#x60;${library.directory}/**/*.scss&#x60;);

        scssFilesPaths.forEach((fileName) &#x3D;&gt; {
          const ast &#x3D; postcss.parse(readFileSync(fileName).toString());
          const imports &#x3D; new Set&lt;string&gt;();
          ast.walk((node) &#x3D;&gt; {
            if (node.type &#x3D;&#x3D;&#x3D; &#x27;atrule&#x27; &amp;&amp; node.name &#x3D;&#x3D;&#x3D; &#x27;import&#x27;) {
              const path &#x3D; node.params.replace(/[&#x27;&quot;]+/g, &#x27;&#x27;);
              imports.add(path);
            }
          });
          imports.forEach((val) &#x3D;&gt; {
            if (scssImports[val]) {
              scssImports[val].files.add(fileName);
            } else {
              scssImports[val] &#x3D; {
                importPath: val,
                files: new Set&lt;string&gt;([fileName]),
              };
            }
          });
        });

        return {
          ...library,
          scssImports,
          tsImports,
          externalDependencies: {},
          externalDependenciesForPackageJson: {},
        };
      }
    )
    .reduce((acc: Record&lt;string, LibraryWithDependencies&gt;, curr) &#x3D;&gt; {
      acc[curr.name] &#x3D; curr;
      return acc;
    }, {});

  // Check where imports are used (spec, lib, schematics, schematics spec)
  categorizeUsageOfDependencies(libraries);

  // Check for rxjs/internal imports
  checkRxInternalImports(libraries, options);

  // Filter out al the relative paths for our source code
  filterLocalRelativeImports(libraries);

  // Check if we use node dependencies where we should not, then filter native Node imports.
  filterNativeNodeAPIs(libraries, options);

  // Check if we use absolute paths where we should not, then filter these.
  filterLocalAbsolutePathFiles(libraries, options);

  // Define list of external dependencies for each library
  extractExternalDependenciesFromImports(libraries);

  const rootPackageJsonContent: PackageJson &#x3D; readJsonFile(&#x60;./${PACKAGE_JSON}&#x60;);

  // Check if we have all dependencies directly referenced in root package.json
  checkIfWeHaveAllDependenciesInPackageJson(
    libraries,
    rootPackageJsonContent,
    options
  );

  // Filer out spec dependencies as we already checked everything related to them
  filterOutSpecOnlyDependencies(libraries);

  // Add to lib package.json missing dependencies
  addMissingDependenciesToPackageJson(
    libraries,
    rootPackageJsonContent,
    options
  );

  // Remove unused dependencies from libraries package.json files
  removeNotUsedDependenciesFromPackageJson(libraries, options);

  // Make sure that libraries don&#x27;t have devDependencies
  checkEmptyDevDependencies(libraries, options);

  // Check if all TS packages have dependency on tslib
  checkTsLibDep(libraries, rootPackageJsonContent, options);

  // Check if libraries doesn&#x27;t use local node_modules
  checkForLockFile(libraries, options);

  // Synchronize version in libraries dependencies to root package.json
  updateDependenciesVersions(libraries, rootPackageJsonContent, options);

  if (options.fix) {
    savePackageJsonFiles(libraries);
  }
}

/**
 * Remove these imports from the object as it is no longer useful in processing.
 */
function filterLocalRelativeImports(
  libraries: Record&lt;string, LibraryWithDependencies&gt;
): void {
  Object.values(libraries).forEach((lib) &#x3D;&gt; {
    lib.tsImports &#x3D; Object.values(lib.tsImports)
      .filter((imp) &#x3D;&gt; !imp.importPath.startsWith(&#x27;.&#x27;))
      .reduce((acc, curr) &#x3D;&gt; {
        acc[curr.importPath] &#x3D; curr;
        return acc;
      }, {} as LibraryWithDependencies[&#x27;tsImports&#x27;]);
    lib.scssImports &#x3D; Object.values(lib.scssImports)
      .filter(
        (imp) &#x3D;&gt;
          imp.importPath.startsWith(&#x27;node_modules/&#x27;) ||
          imp.importPath.startsWith(&#x27;~&#x27;)
      )
      .reduce((acc, curr) &#x3D;&gt; {
        acc[curr.importPath] &#x3D; curr;
        return acc;
      }, {} as LibraryWithDependencies[&#x27;scssImports&#x27;]);
  });
}

/**
 * Filter native Node.js APIs
 */
function filterNativeNodeAPIs(
  libraries: Record&lt;string, LibraryWithDependencies&gt;,
  options: ProgramOptions
): void {
  const nodeAPIs &#x3D; [
    &#x27;fs&#x27;,
    &#x27;fs/promise&#x27;,
    &#x27;path&#x27;,
    &#x27;events&#x27;,
    &#x27;assert&#x27;,
    &#x27;async_hooks&#x27;,
    &#x27;child_process&#x27;,
    &#x27;cluster&#x27;,
    &#x27;crypto&#x27;,
    &#x27;diagnostics_channel&#x27;,
    &#x27;dns&#x27;,
    &#x27;domain&#x27;,
    &#x27;http&#x27;,
    &#x27;http2&#x27;,
    &#x27;https&#x27;,
    &#x27;inspector&#x27;,
    &#x27;net&#x27;,
    &#x27;os&#x27;,
    &#x27;perf_hooks&#x27;,
    &#x27;process&#x27;,
    &#x27;punycode&#x27;,
    &#x27;querystring&#x27;,
    &#x27;readline&#x27;,
    &#x27;repl&#x27;,
    &#x27;stream&#x27;,
    &#x27;string_decoder&#x27;,
    &#x27;tls&#x27;,
    &#x27;trace_events&#x27;,
    &#x27;tty&#x27;,
    &#x27;dgram&#x27;,
    &#x27;url&#x27;,
    &#x27;util&#x27;,
    &#x27;v8&#x27;,
    &#x27;vm&#x27;,
    &#x27;wasi&#x27;,
    &#x27;worker_threads&#x27;,
    &#x27;zlib&#x27;,
  ];

  if (!options.fix) {
    reportProgress(&#x27;Checking imports of Node.js APIs&#x27;);

    let errorsFound &#x3D; false;
    Object.values(libraries).forEach((lib) &#x3D;&gt; {
      lib.tsImports &#x3D; Object.values(lib.tsImports)
        .filter((imp) &#x3D;&gt; {
          if (nodeAPIs.includes(imp.importPath)) {
            // Don&#x27;t run the check in fix mode
            if (!options.fix) {
              // Don&#x27;t allow to use node api outside of schematics spec files
              if (
                imp.usageIn.spec ||
                imp.usageIn.lib ||
                imp.usageIn.schematics
              ) {
                imp.files.forEach((file) &#x3D;&gt; {
                  // Allow to use Node APIs in SSR
                  if (!file.includes(&#x27;ssr&#x27;)) {
                    errorsFound &#x3D; true;
                    error(
                      file,
                      [
                        &#x60;Node.js API \&#x60;${chalk.bold(
                          imp.importPath
                        )}\&#x60; is referenced.&#x60;,
                      ],
                      [
                        &#x60;Node.js APIs can only be used in SSR code or in schematics specs.&#x60;,
                        &#x60;You might have wanted to import it from some library instead.&#x60;,
                      ]
                    );
                  }
                });
              }
            }
            return false;
          }
          return true;
        })
        .reduce((acc, curr) &#x3D;&gt; {
          acc[curr.importPath] &#x3D; curr;
          return acc;
        }, {} as LibraryWithDependencies[&#x27;tsImports&#x27;]);
    });
    if (!errorsFound) {
      success();
    }
  }
}

/**
 * Filer native Node.js APIs
 */
function filterLocalAbsolutePathFiles(
  libraries: Record&lt;string, LibraryWithDependencies&gt;,
  options: ProgramOptions
): void {
  if (!options.fix) {
    reportProgress(&#x27;Checking absolute path imports&#x27;);

    let errorsFound &#x3D; false;
    Object.values(libraries).forEach((lib) &#x3D;&gt; {
      lib.tsImports &#x3D; Object.values(lib.tsImports)
        .filter((imp) &#x3D;&gt; {
          if (
            fs.existsSync(imp.importPath) ||
            fs.existsSync(&#x60;${imp.importPath}.ts&#x60;)
          ) {
            // Don&#x27;t run in fix mode
            if (!options.fix) {
              // Allow to use absolute paths for spec files
              if (
                imp.usageIn.lib ||
                imp.usageIn.schematics ||
                imp.usageIn.schematicsSpec
              ) {
                imp.files.forEach((file) &#x3D;&gt; {
                  errorsFound &#x3D; true;
                  error(
                    file,
                    [
                      &#x60;Absolute import should not be used outside of spec files.\n    Referenced \&#x60;${chalk.bold(
                        imp.importPath
                      )}\&#x60;&#x60;,
                    ],
                    [
                      &#x60;You can use absolute paths only in test files.&#x60;,
                      &#x60;Use relative or entry point import instead.&#x60;,
                    ]
                  );
                });
              }
            }
            return false;
          }
          return true;
        })
        .reduce((acc, curr) &#x3D;&gt; {
          acc[curr.importPath] &#x3D; curr;
          return acc;
        }, {} as LibraryWithDependencies[&#x27;tsImports&#x27;]);
    });
    if (!errorsFound) {
      success();
    }
  }
}

/**
 * Categorize in which type of files we use different dependencies
 */
function categorizeUsageOfDependencies(
  libraries: Record&lt;string, LibraryWithDependencies&gt;
): void {
  Object.values(libraries).forEach((lib) &#x3D;&gt; {
    Object.values(lib.tsImports).forEach((imp) &#x3D;&gt; {
      imp.files.forEach((file) &#x3D;&gt; {
        if (file.endsWith(&#x27;_spec.ts&#x27;)) {
          imp.usageIn.schematicsSpec &#x3D; true;
        } else if (
          file.endsWith(&#x27;spec.ts&#x27;) ||
          file &#x3D;&#x3D;&#x3D; &#x60;${lib.directory}/test.ts&#x60; ||
          file &#x3D;&#x3D;&#x3D; &#x60;${lib.directory}/src/test.ts&#x60;
        ) {
          imp.usageIn.spec &#x3D; true;
        } else if (file.includes(&#x27;schematics&#x27;)) {
          imp.usageIn.schematics &#x3D; true;
        } else {
          imp.usageIn.lib &#x3D; true;
        }
      });
    });
  });
}

/**
 * Check rxjs/internal imports
 */
function checkRxInternalImports(
  libraries: Record&lt;string, LibraryWithDependencies&gt;,
  options: ProgramOptions
): void {
  if (!options.fix) {
    reportProgress(&#x27;Checking &#x60;rx/internal&#x60; imports&#x27;);
    let errorsFound &#x3D; false;
    Object.values(libraries).forEach((lib) &#x3D;&gt; {
      Object.values(lib.tsImports).forEach((imp) &#x3D;&gt; {
        if (imp.importPath.includes(&#x27;rxjs/internal&#x27;)) {
          imp.files.forEach((file) &#x3D;&gt; {
            errorsFound &#x3D; true;
            error(
              file,
              [&#x60;\&#x60;${chalk.bold(imp.importPath)}\&#x60; internal import used.&#x60;],
              [
                &#x60;To import from rxjs library you should use \&#x60;${chalk.bold(
                  &#x27;rxjs&#x27;
                )}\&#x60; or \&#x60;${chalk.bold(&#x27;rxjs/operators&#x27;)}\&#x60; imports.&#x60;,
              ]
            );
          });
        }
      });
    });
    if (!errorsFound) {
      success();
    }
  }
}

/**
 * Extract external dependencies from imports
 */
function extractExternalDependenciesFromImports(
  libraries: Record&lt;string, LibraryWithDependencies&gt;
): void {
  Object.values(libraries).forEach((lib) &#x3D;&gt; {
    Object.values(lib.tsImports).forEach((imp) &#x3D;&gt; {
      let dependency: string;
      if (imp.importPath.startsWith(&#x27;@&#x27;)) {
        const [scope, name] &#x3D; imp.importPath.split(&#x27;/&#x27;);
        dependency &#x3D; &#x60;${scope}/${name}&#x60;;
      } else {
        const [name] &#x3D; imp.importPath.split(&#x27;/&#x27;);
        dependency &#x3D; &#x60;${name}&#x60;;
      }

      if (!lib.externalDependencies[dependency]) {
        lib.externalDependencies[dependency] &#x3D; {
          dependency,
          files: new Set&lt;string&gt;(),
          usageIn: {
            lib: false,
            spec: false,
            schematics: false,
            schematicsSpec: false,
            styles: false,
          },
        };
      }
      imp.files.forEach((file) &#x3D;&gt; {
        lib.externalDependencies[dependency].files.add(file);
      });
      if (imp.usageIn.lib) {
        lib.externalDependencies[dependency].usageIn.lib &#x3D; true;
      }
      if (imp.usageIn.schematics) {
        lib.externalDependencies[dependency].usageIn.schematics &#x3D; true;
      }
      if (imp.usageIn.schematicsSpec) {
        lib.externalDependencies[dependency].usageIn.schematicsSpec &#x3D; true;
      }
      if (imp.usageIn.spec) {
        lib.externalDependencies[dependency].usageIn.spec &#x3D; true;
      }
    });
    Object.values(lib.scssImports).forEach((imp) &#x3D;&gt; {
      let dependency: string;
      let dep;
      if (imp.importPath.startsWith(&#x27;~&#x27;)) {
        dep &#x3D; imp.importPath.substring(1);
      } else {
        dep &#x3D; imp.importPath.substring(&#x27;node_modules/&#x27;.length);
      }
      if (dep.startsWith(&#x27;@&#x27;)) {
        const [scope, name] &#x3D; dep.split(&#x27;/&#x27;);
        dependency &#x3D; &#x60;${scope}/${name}&#x60;;
      } else {
        const [name] &#x3D; dep.split(&#x27;/&#x27;);
        dependency &#x3D; &#x60;${name}&#x60;;
      }

      if (!lib.externalDependencies[dependency]) {
        lib.externalDependencies[dependency] &#x3D; {
          dependency,
          files: new Set&lt;string&gt;(),
          usageIn: {
            lib: false,
            spec: false,
            schematics: false,
            schematicsSpec: false,
            styles: false,
          },
        };
      }
      imp.files.forEach((file) &#x3D;&gt; {
        lib.externalDependencies[dependency].files.add(file);
      });
      lib.externalDependencies[dependency].usageIn.styles &#x3D; true;
    });
  });
}

/**
 * Get external dependencies from imports
 */
function checkIfWeHaveAllDependenciesInPackageJson(
  libraries: Record&lt;string, LibraryWithDependencies&gt;,
  packageJson: PackageJson,
  options: ProgramOptions
): void {
  if (!options.fix) {
    const allDeps &#x3D; {
      ...packageJson.devDependencies,
      ...packageJson.dependencies,
    };
    const errors: string[] &#x3D; [];
    reportProgress(&#x60;Checking for missing dependencies in root ${PACKAGE_JSON}&#x60;);
    Object.values(libraries).forEach((lib) &#x3D;&gt; {
      Object.values(lib.externalDependencies).forEach((dep) &#x3D;&gt; {
        if (
          !dep.dependency.startsWith(&#x60;${SPARTACUS_SCOPE}/&#x60;) &amp;&amp;
          !Object.keys(allDeps).includes(dep.dependency)
        ) {
          errors.push(
            &#x60;Missing \&#x60;${chalk.bold(
              dep.dependency
            )}\&#x60; dependency that is used directly in \&#x60;${chalk.bold(
              lib.name
            )}\&#x60;.&#x60;
          );
        }
      });
    });
    if (errors.length) {
      error(PACKAGE_JSON, errors, [
        &#x60;All dependencies that are directly referenced should be specified as \&#x60;${chalk.bold(
          &#x27;dependencies&#x27;
        )}\&#x60; or \&#x60;${chalk.bold(&#x27;devDependencies&#x27;)}\&#x60;.&#x60;,
        &#x60;Install them with \&#x60;${chalk.bold(
          &#x27;yarn add &lt;dependency-name&gt; [--dev]&#x27;
        )}\&#x60;.&#x60;,
      ]);
    } else {
      success();
    }
  }
}

/**
 * Remove spec external dependencies as we already took care of them.
 */
function filterOutSpecOnlyDependencies(
  libraries: Record&lt;string, LibraryWithDependencies&gt;
): void {
  Object.values(libraries).forEach((lib) &#x3D;&gt; {
    lib.externalDependenciesForPackageJson &#x3D; Object.values(
      lib.externalDependencies
    )
      .filter((dep) &#x3D;&gt; {
        if (
          !dep.usageIn.lib &amp;&amp;
          !dep.usageIn.schematics &amp;&amp;
          !dep.usageIn.styles
        ) {
          return false;
        }
        return true;
      })
      .reduce((acc, curr) &#x3D;&gt; {
        acc[curr.dependency] &#x3D; curr;
        return acc;
      }, {} as LibraryWithDependencies[&#x27;externalDependenciesForPackageJson&#x27;]);
  });
}

/**
 * Adds peerDependencies to libraries package.json files
 */
function addMissingDependenciesToPackageJson(
  libraries: Record&lt;string, LibraryWithDependencies&gt;,
  rootPackageJson: PackageJson,
  options: ProgramOptions
): void {
  const deps: PackageJson[&#x27;dependencies&#x27;] | PackageJson[&#x27;devDependencies&#x27;] &#x3D; {
    ...rootPackageJson.dependencies,
    ...rootPackageJson.devDependencies,
  };
  if (options.fix) {
    reportProgress(&#x27;Updating missing peerDependencies&#x27;);
  } else {
    reportProgress(&#x27;Checking for missing peerDependencies&#x27;);
  }
  const updates &#x3D; new Set&lt;string&gt;();
  let errorsFound &#x3D; false;
  Object.values(libraries).forEach((lib) &#x3D;&gt; {
    const pathToPackageJson &#x3D; &#x60;${lib.directory}/${PACKAGE_JSON}&#x60;;
    const errors: string[] &#x3D; [];
    Object.values(lib.externalDependenciesForPackageJson).forEach((dep) &#x3D;&gt; {
      if (
        typeof lib.dependencies[dep.dependency] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp;
        typeof lib.peerDependencies[dep.dependency] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp;
        typeof lib.optionalDependencies[dep.dependency] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp;
        dep.dependency !&#x3D;&#x3D; lib.name
      ) {
        if (options.fix) {
          const packageJson &#x3D; lib.packageJsonContent;
          const version &#x3D; deps[dep.dependency];
          if (
            typeof version &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp;
            !dep.dependency.startsWith(&#x60;${SPARTACUS_SCOPE}/&#x60;)
          ) {
            // Nothing we can do here. First the dependencies must be added to root package.json (previous check).
          } else {
            if (typeof packageJson.peerDependencies &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
              packageJson.peerDependencies &#x3D; {};
            }
            if (typeof version !&#x3D;&#x3D; &#x27;undefined&#x27;) {
              packageJson.peerDependencies[dep.dependency] &#x3D; version;
              updates.add(pathToPackageJson);
            } else if (dep.dependency !&#x3D;&#x3D; lib.name) {
              packageJson.peerDependencies[dep.dependency] &#x3D;
                libraries[dep.dependency].version;
              updates.add(pathToPackageJson);
            }
          }
        } else {
          errors.push(
            &#x60;Missing \&#x60;${chalk.bold(
              dep.dependency
            )}\&#x60; dependency that is directly referenced in library.&#x60;
          );
        }
      }
    });
    if (errors.length) {
      errorsFound &#x3D; true;
      error(pathToPackageJson, errors, [
        &#x60;All dependencies that are directly referenced should be specified as \&#x60;${chalk.bold(
          &#x27;dependencies&#x27;
        )}\&#x60; or \&#x60;${chalk.bold(&#x27;peerDependencies&#x27;)}\&#x60;.&#x60;,
        &#x60;Adding new \&#x60;${chalk.bold(
          &#x27;peerDependency&#x27;
        )}\&#x60; might be a breaking change!&#x60;,
        &#x60;This can be automatically fixed by running \&#x60;${chalk.bold(
          &#x27;yarn config:update&#x27;
        )}\&#x60;.&#x60;,
      ]);
    }
  });
  if (options.fix) {
    if (updates.size &gt; 0) {
      updates.forEach((packageJsonPath) &#x3D;&gt; {
        logUpdatedFile(packageJsonPath);
      });
    } else {
      success();
    }
  } else if (!errorsFound) {
    success();
  }
}

/**
 * Remove dependencies that are no longer referenced in the library
 */
function removeNotUsedDependenciesFromPackageJson(
  libraries: Record&lt;string, LibraryWithDependencies&gt;,
  options: ProgramOptions
): void {
  // Keep these dependencies in schematics as these are used as external schematics
  const externalSchematics &#x3D; [&#x27;@angular/pwa&#x27;, &#x27;@nguniversal/express-engine&#x27;];

  if (options.fix) {
    reportProgress(&#x27;Removing unused dependencies&#x27;);
  } else {
    reportProgress(&#x27;Checking unused dependencies&#x27;);
  }
  const updates &#x3D; new Set&lt;string&gt;();
  let errorsFound &#x3D; false;
  Object.values(libraries).forEach((lib) &#x3D;&gt; {
    const deps &#x3D; {
      ...lib.dependencies,
      ...lib.peerDependencies,
      ...lib.optionalDependencies,
    };
    const errors: string[] &#x3D; [];
    const pathToPackageJson &#x3D; &#x60;${lib.directory}/${PACKAGE_JSON}&#x60;;
    Object.keys(deps).forEach((dep) &#x3D;&gt; {
      if (
        typeof lib.externalDependenciesForPackageJson[dep] &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp;
        dep !&#x3D;&#x3D; &#x60;tslib&#x60; &amp;&amp;
        ((lib.name &#x3D;&#x3D;&#x3D; SPARTACUS_SCHEMATICS &amp;&amp;
          !externalSchematics.includes(dep)) ||
          lib.name !&#x3D;&#x3D; SPARTACUS_SCHEMATICS)
      ) {
        if (options.fix) {
          const packageJson &#x3D; lib.packageJsonContent;
          if (typeof packageJson?.dependencies?.[dep] !&#x3D;&#x3D; &#x27;undefined&#x27;) {
            delete packageJson.dependencies[dep];
            updates.add(pathToPackageJson);
          } else if (
            typeof packageJson?.peerDependencies?.[dep] !&#x3D;&#x3D; &#x27;undefined&#x27;
          ) {
            delete packageJson.peerDependencies[dep];
            updates.add(pathToPackageJson);
          } else if (
            typeof packageJson?.optionalDependencies?.[dep] !&#x3D;&#x3D; &#x27;undefined&#x27;
          ) {
            delete packageJson.optionalDependencies[dep];
            updates.add(pathToPackageJson);
          }
        } else {
          errors.push(
            &#x60;Dependency \&#x60;${chalk.bold(
              dep
            )}\&#x60; is not used in the \&#x60;${chalk.bold(lib.name)}\&#x60;.&#x60;
          );
        }
      }
    });
    if (errors.length &gt; 0) {
      errorsFound &#x3D; true;
      error(pathToPackageJson, errors, [
        &#x60;Dependencies that are not used should not be specified in package list of \&#x60;${chalk.bold(
          &#x27;dependencies&#x27;
        )}\&#x60; or \&#x60;${chalk.bold(&#x27;peerDependencies&#x27;)}\&#x60;.&#x60;,
        &#x60;This can be automatically fixed by running \&#x60;${chalk.bold(
          &#x27;yarn config:update&#x27;
        )}\&#x60;.&#x60;,
      ]);
    }
  });
  if (options.fix) {
    if (updates.size &gt; 0) {
      updates.forEach((packageJsonPath) &#x3D;&gt; {
        logUpdatedFile(packageJsonPath);
      });
    } else {
      success();
    }
  } else if (!errorsFound) {
    success();
  }
}

/**
 * Check if package does not have any devDependencies
 */
function checkEmptyDevDependencies(
  libraries: Record&lt;string, LibraryWithDependencies&gt;,
  options: ProgramOptions
): void {
  if (!options.fix) {
    reportProgress(&#x27;Checking unnecessary &#x60;devDependencies&#x60;&#x27;);
    let errorsFound &#x3D; false;
    Object.values(libraries).forEach((lib) &#x3D;&gt; {
      if (Object.keys(lib.devDependencies).length &gt; 0) {
        const pathToPackageJson &#x3D; &#x60;${lib.directory}/${PACKAGE_JSON}&#x60;;
        errorsFound &#x3D; true;
        error(
          pathToPackageJson,
          [
            &#x60;Libraries should not have \&#x60;${chalk.bold(
              &#x27;devDependencies&#x27;
            )}\&#x60; specified in their ${PACKAGE_JSON}.&#x60;,
          ],
          [
            &#x60;You should use \&#x60;${chalk.bold(
              &#x27;devDependencies&#x27;
            )}\&#x60; from root ${PACKAGE_JSON} file.&#x60;,
            &#x60;You should remove this section from this ${PACKAGE_JSON}.&#x60;,
          ]
        );
      }
    });
    if (!errorsFound) {
      success();
    }
  }
}

// Check if we have everywhere tslib dependency
function checkTsLibDep(
  libraries: Record&lt;string, LibraryWithDependencies&gt;,
  rootPackageJson: PackageJson,
  options: ProgramOptions
): void {
  const tsLibName &#x3D; &#x27;tslib&#x27;;
  const tsLibVersion &#x3D; rootPackageJson.dependencies?.[tsLibName];
  if (options.fix) {
    reportProgress(&#x60;Updating \&#x60;${tsLibName}\&#x60; dependency usage&#x60;);
  } else {
    reportProgress(&#x60;Checking \&#x60;${tsLibName}\&#x60; dependency usage&#x60;);
  }
  const updates &#x3D; new Set&lt;string&gt;();
  let errorsFound &#x3D; false;
  Object.values(libraries).forEach((lib) &#x3D;&gt; {
    // Styles library is the only library without TS
    if (lib.name !&#x3D;&#x3D; &#x60;${SPARTACUS_SCOPE}/styles&#x60;) {
      const pathToPackageJson &#x3D; &#x60;${lib.directory}/${PACKAGE_JSON}&#x60;;
      const errors &#x3D; [];
      if (!Object.keys(lib.dependencies).includes(tsLibName)) {
        if (options.fix) {
          const packageJson &#x3D; lib.packageJsonContent;
          if (typeof packageJson?.dependencies &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
            packageJson.dependencies &#x3D; {};
          }
          packageJson.dependencies[tsLibName] &#x3D; tsLibVersion!;
          updates.add(pathToPackageJson);
        } else {
          errors.push(
            &#x60;Missing \&#x60;${chalk.bold(tsLibName)}\&#x60; dependency in \&#x60;${chalk.bold(
              &#x27;dependencies&#x27;
            )}\&#x60; list.&#x60;
          );
        }
      }
      if (Object.keys(lib.peerDependencies).includes(tsLibName)) {
        if (options.fix) {
          const packageJson &#x3D; lib.packageJsonContent;
          delete packageJson.peerDependencies?.[tsLibName];
          updates.add(pathToPackageJson);
        } else {
          errors.push(
            &#x60;Dependency \&#x60;${chalk.bold(
              tsLibName
            )}\&#x60; should be in \&#x60;${chalk.bold(
              &#x27;dependencies&#x27;
            )}\&#x60; list. Not in the \&#x60;${chalk.bold(&#x27;peerDependencies&#x27;)}\&#x60;.&#x60;
          );
        }
      }
      if (Object.keys(lib.optionalDependencies).includes(tsLibName)) {
        if (options.fix) {
          const packageJson &#x3D; lib.packageJsonContent;
          delete packageJson.optionalDependencies?.[tsLibName];
          updates.add(pathToPackageJson);
        } else {
          errors.push(
            &#x60;Dependency \&#x60;${chalk.bold(
              tsLibName
            )}\&#x60; should be in \&#x60;${chalk.bold(
              &#x27;dependencies&#x27;
            )}\&#x60; list. Not in the \&#x60;${chalk.bold(&#x27;optionalDependency&#x27;)}\&#x60;.&#x60;
          );
        }
      }
      if (errors.length &gt; 0) {
        errorsFound &#x3D; true;
        error(pathToPackageJson, errors, [
          &#x60;Each TS package should have \&#x60;${chalk.bold(
            tsLibName
          )}\&#x60; specified as \&#x60;${chalk.bold(&#x27;dependency&#x27;)}.&#x60;,
          &#x60;This can be automatically fixed by running \&#x60;${chalk.bold(
            &#x27;yarn config:update&#x27;
          )}\&#x60;.&#x60;,
        ]);
      }
    }
  });
  if (options.fix) {
    if (updates.size &gt; 0) {
      updates.forEach((packageJsonPath) &#x3D;&gt; {
        logUpdatedFile(packageJsonPath);
      });
    } else {
      success();
    }
  } else if (!errorsFound) {
    success();
  }
}

function checkForLockFile(
  libraries: Record&lt;string, LibraryWithDependencies&gt;,
  options: ProgramOptions
): void {
  if (!options.fix) {
    reportProgress(&#x27;Checking for unnecessary &#x60;yarn.lock&#x60; files&#x27;);
    let errorsFound &#x3D; false;
    Object.values(libraries).forEach((lib) &#x3D;&gt; {
      const lockFile &#x3D; glob.sync(&#x60;${lib.directory}/yarn.lock&#x60;);
      if (lockFile.length &gt; 0) {
        errorsFound &#x3D; true;
        error(
          lockFile[0],
          [
            &#x60;Library \&#x60;${chalk.bold(
              lib.name
            )}\&#x60; should not have its own \&#x60;${chalk.bold(&#x27;yarn.lock&#x27;)}\&#x60;.&#x60;,
          ],
          [
            &#x60;Libraries should use packages from root \&#x60;${chalk.bold(
              PACKAGE_JSON
            )}\&#x60; and root \&#x60;${chalk.bold(&#x27;node_modules&#x27;)}\&#x60;.&#x60;,
          ]
        );
      }
    });
    if (!errorsFound) {
      success();
    }
  }
}

/**
 * Update versions in all libraries package json files
 */
function updateDependenciesVersions(
  libraries: Record&lt;string, LibraryWithDependencies&gt;,
  rootPackageJson: PackageJson,
  options: ProgramOptions
): void {
  const rootDeps:
    | PackageJson[&#x27;dependencies&#x27;]
    | PackageJson[&#x27;devDependencies&#x27;] &#x3D; {
    ...rootPackageJson.dependencies,
    ...rootPackageJson.devDependencies,
  };
  if (options.fix) {
    reportProgress(
      &#x60;Updating packages versions between libraries and root ${PACKAGE_JSON}&#x60;
    );
  } else {
    reportProgress(
      &#x60;Checking packages versions between libraries and root ${PACKAGE_JSON}&#x60;
    );
  }
  const updates &#x3D; new Set&lt;string&gt;();
  let errorsFound &#x3D; false;
  Object.values(libraries).forEach((lib) &#x3D;&gt; {
    const pathToPackageJson &#x3D; &#x60;${lib.directory}/${PACKAGE_JSON}&#x60;;
    const packageJson &#x3D; lib.packageJsonContent;
    const types &#x3D; [
      &#x27;dependencies&#x27;,
      &#x27;peerDependencies&#x27;,
      &#x27;optionalDependencies&#x27;,
    ] as const;
    const errors: string[] &#x3D; [];
    const internalErrors: string[] &#x3D; [];
    const breakingErrors: string[] &#x3D; [];
    types.forEach((type) &#x3D;&gt; {
      Object.keys(packageJson[type] ?? {}).forEach((dep) &#x3D;&gt; {
        if (!semver.validRange(packageJson[type]?.[dep])) {
          if (!options.fix) {
            errorsFound &#x3D; true;
            error(
              pathToPackageJson,
              [
                &#x60;Package \&#x60;${chalk.bold(
                  packageJson[type]?.[dep]
                )}\&#x60; version is not correct.&#x60;,
              ],
              [&#x60;Install package version that follows semver.&#x60;]
            );
          }
          return;
        }
        if (dep.startsWith(SPARTACUS_SCOPE)) {
          if (packageJson[type]?.[dep] !&#x3D;&#x3D; libraries[dep].version) {
            if (options.fix) {
              packageJson[type]![dep] &#x3D; libraries[dep].version;
              updates.add(pathToPackageJson);
            } else {
              internalErrors.push(
                &#x60;Dependency \&#x60;${chalk.bold(
                  dep
                )}\&#x60; have different version \&#x60;${chalk.bold(
                  packageJson[type]?.[dep]
                )}\&#x60; than the package in repository \&#x60;${chalk.bold(
                  libraries[dep].version
                )}\&#x60;.&#x60;
              );
            }
          }
        } else if (
          typeof rootDeps[dep] !&#x3D;&#x3D; &#x27;undefined&#x27; &amp;&amp;
          packageJson[type]?.[dep] !&#x3D;&#x3D; rootDeps[dep]
        ) {
          // Careful with breaking changes!
          if (
            semver.major(semver.minVersion(packageJson[type]![dep])!) &#x3D;&#x3D;&#x3D;
              semver.major(semver.minVersion(rootDeps[dep])!) &amp;&amp;
            semver.gte(
              semver.minVersion(packageJson[type]![dep])!,
              semver.minVersion(rootDeps[dep])!
            )
          ) {
            // not a breaking change!
            if (options.fix) {
              packageJson[type]![dep] &#x3D; rootDeps[dep];
              updates.add(pathToPackageJson);
            } else {
              errors.push(
                &#x60;Dependency \&#x60;${chalk.bold(
                  dep
                )}\&#x60; have different version \&#x60;${chalk.bold(
                  packageJson[type]?.[dep]
                )}\&#x60; than the package in root \&#x60;${chalk.bold(
                  PACKAGE_JSON
                )}\&#x60; file \&#x60;${chalk.bold(rootDeps[dep])}\&#x60;.&#x60;
              );
            }
          } else {
            // breaking change!
            if (options.bumpVersions &amp;&amp; options.fix) {
              packageJson[type]![dep] &#x3D; rootDeps[dep];
              updates.add(pathToPackageJson);
            } else if (!options.fix) {
              breakingErrors.push(
                &#x60;Dependency \&#x60;${chalk.bold(
                  dep
                )}\&#x60; have different version \&#x60;${chalk.bold(
                  packageJson[type]?.[dep]
                )}\&#x60; than the package in root \&#x60;${chalk.bold(
                  PACKAGE_JSON
                )}\&#x60; file \&#x60;${chalk.bold(rootDeps[dep])}\&#x60;.&#x60;
              );
            }
          }
        }
      });
    });
    if (internalErrors.length &gt; 0) {
      errorsFound &#x3D; true;
      error(pathToPackageJson, internalErrors, [
        &#x60;All spartacus dependencies should be version synchronized.&#x60;,
        &#x60;Version of the package in \&#x60;${chalk.bold(
          &#x27;peerDependencies&#x27;
        )}\&#x60; should match package \&#x60;${chalk.bold(
          &#x27;version&#x27;
        )}\&#x60; from repository.&#x60;,
        &#x60;This can be automatically fixed by running \&#x60;${chalk.bold(
          &#x27;yarn config:update&#x27;
        )}\&#x60;.&#x60;,
      ]);
    }
    if (errors.length &gt; 0) {
      errorsFound &#x3D; true;
      error(pathToPackageJson, errors, [
        &#x60;All external dependencies should have the same version as in the root \&#x60;${chalk.bold(
          PACKAGE_JSON
        )}\&#x60;.&#x60;,
        &#x60;This can be automatically fixed by running \&#x60;${chalk.bold(
          &#x27;yarn config:update&#x27;
        )}\&#x60;.&#x60;,
      ]);
    }
    if (breakingErrors.length &gt; 0) {
      errorsFound &#x3D; true;
      warning(pathToPackageJson, breakingErrors, [
        &#x60;All external dependencies should have the same version as in the root \&#x60;${chalk.bold(
          PACKAGE_JSON
        )}\&#x60;.&#x60;,
        &#x60;Bumping to a higher dependency version should be only done in major releases!&#x60;,
        &#x60;We want to specify everywhere the lowest compatible dependency version with Spartacus.&#x60;,
        &#x60;This can be automatically fixed by running \&#x60;${chalk.bold(
          &#x27;yarn config:update --bump-versions&#x27;
        )}\&#x60;.&#x60;,
      ]);
    }
  });
  if (options.fix) {
    if (updates.size &gt; 0) {
      updates.forEach((packageJsonPath) &#x3D;&gt; {
        logUpdatedFile(packageJsonPath);
      });
    } else {
      success();
    }
  } else if (!errorsFound) {
    success();
  }
}

/**
 * Save updated package.json files.
 */
function savePackageJsonFiles(
  libraries: Record&lt;string, LibraryWithDependencies&gt;
) {
  reportProgress(&#x27;Saving package.json files to disk&#x27;);
  Object.values(libraries).forEach((lib) &#x3D;&gt; {
    const pathToPackageJson &#x3D; &#x60;${lib.directory}/${PACKAGE_JSON}&#x60;;
    const packageJson &#x3D; lib.packageJsonContent;
    saveJsonFile(pathToPackageJson, packageJson);
    execSync(&#x60;cd ${lib.directory} &amp;&amp; npx sort-package-json&#x60;, {
      stdio: &#x27;ignore&#x27;,
    });
    logUpdatedFile(pathToPackageJson);
  });
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'LibraryWithDependencies.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
